# デザインパターン（PHP）

## オブジェクトの生成に関するパターン

### Abstract Factory

互いに関連したり依存し合うオブジェクト群を、その具象クラスを明確にせず生成するためのインタフェースを提供する。

### Builder

複合オブジェクトについて、その作成過程を表現形式に依存しないものにすることにより、
同じ作成過程で異なる表現形式のオブジェクトを生成できるようにする。

### Factory Method

オブジェクトを生成するときのインタフェースだけを規定して、実際にどのクラスをインスタンス化するかはサブクラスが決めるようにする。
Factory Methodパターンは、インスタンス化をサブクラスに任せる。

### Prototype

生成すべきオブジェクトの種類を原型となるインスタンスを使って明確にし、それをコピーすることで新たなオブジェクトの生成を行う。

### Singleton

あるクラスに対してインスタンスが１つしか存在しないことを保証し、それにアクセスするためのグローバルな方法を提供する。

## プログラムの構造に関するパターン

### Adapter

あるクラスのインタフェースを、クライアントが求める他のインタフェースへ変換する。
Adapterパターンは、インタフェースに互換性のないクラス同士を組み合わせることができるようにする。

### Bridge

抽出されたクラスと実装を分離して、それらを独立に変更できるようにする。

### Composite

部分−全体階層を表現するために、オブジェクトを木構造に組み立てる。
Compositeパターンにより、クライアントは、個々のオブジェクトとオブジェクトを合成したものを一様に扱うことができるようになる。

### Decorator

オブジェクトに責任を動的に追加する。Decoratorパターンは、サブクラス化よりも柔軟な機能拡張方法を提供する。

### Façade

サブシステム内に存在する複数のインタフェースに１つの統一インタフェースを与える。
Façadeパターンはサブシステムの利用を容易にするための高レベルインタフェースを定義する。

### Flyweight

多数の細かいオブジェクトを効率よくサポートするために共有を利用する。

### Proxy

あるオブジェクトへのアクセスを制御するために、そのオブジェクトの代理、または入れ物を提供する。

## オブジェクトの振る舞いに関するパターン

### Chain of Responsibility

1つ以上のオブジェクトに要求を処理する機会を与えることにより、要求を送信するオブジェクトと受信するオブジェクトの結合を避ける。
受信する複数のオブジェクトをチェーン状につなぎ、あるオブジェクトがその要求を処理するまで、そのチェーンに沿って要求を渡していく。

### Command

要求をオブジェクトとしてカプセル化することによって、異なる要求や、要求からなるキューやログにより、クライアントをパラメータ化する。また、取り消し可能なオペレーションをサポートする。

### Interpreter

言語に対して、文法表現と、それを使用して文を解釈するインタプリタを一緒に定義する。

### Iterator

集約オブジェクトが基にある内部表現を公開せずに、その要素に順にアクセスする方法を提供する。

### Mediator

オブジェクト群の相互作用をカプセル化するオブジェクトを定義する。
Mediatorパターンは、オブジェクト同士がお互いに明示的に参照しあうことがないようにして、結合度を低めることを促進する。
それにより、オブジェクトの相互作用を独立に変えることができるようになる。

### Memento

カプセル化を破壊せずに、オブジェクトの内部状態を捉えて外面化しておき、オブジェクトを後にこの状態に戻すことができるようにする。

### Observer

あるオブジェクトが状態を変えたときに、それに依存するすべてのオブジェクトに自動的にそのことが知らされ、
また、それらが更新されるように、オブジェクト間に一対多の依存関係を定義する。

### State

オブジェクトの内部状態が変化したときに、オブジェクトが振る舞いを変えるようにする。
クラス内では振る舞いの変化を記述せず、状態を表すオブジェクトを導入することでこれを実現する。

### Strategy

アルゴリズムの集合を定義し、各アルゴリズムをカプセル化して、それらを変換可能にする。
Strategyパターンを利用することで、アルゴリズムを、それを利用するクライアントからは独立に変更することができるようになる。

### Template Method

１つのオペレーションにアルゴリズムのスケルトンを定義しておき、
その中のいくつかのステップについては、サブクラスでの定義に任せる事にする。
Template Methodパターンでは、アルゴリズムの構造を変えずに、アルゴリズム中のあるステップをサブクラスで定義する。

### Visitor

あるオブジェクトを構造上の要素で実行されるオペレーションを表現する。
Visitorパターンにより、オペレーションを加えるオブジェクトのクラスに変更を加えずに、
新しいオペレーションを定義することができるようになる。
